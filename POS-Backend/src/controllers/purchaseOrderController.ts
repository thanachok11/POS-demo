import { Request, Response } from "express";
import mongoose from "mongoose";
import PurchaseOrder from "../models/PurchaseOrder";
import { verifyToken } from "../utils/auth";
import { generateInvoiceNumber } from "../utils/generateInvoice";
import { generateBatchNumber } from "../utils/generateBatch";

import Stock from "../models/Stock";
import StockLot from "../models/StockLot";
import Supplier from "../models/Supplier";
import Warehouse from "../models/Warehouse";
import Product from "../models/Product";
import StockTransaction from "../models/StockTransaction";

/* ========================================================
   üîß Helper: ‡∏´‡∏≤ document ‡∏à‡∏≤‡∏Å id ‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠
======================================================== */
async function ensureObjectIdOrByName(model: any, value: any, nameField: string) {
    if (!value) return null;
    if (mongoose.Types.ObjectId.isValid(value)) {
        return await model.findById(value).lean();
    }
    return await model.findOne({ [nameField]: value }).lean();
}

/* ==========================
   ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Purchase Orders ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
========================== */
export const getPurchaseOrders = async (_: Request, res: Response): Promise<void> => {
    try {
        const orders = await PurchaseOrder.find()
            .populate("supplierId")
            .populate("location") // ‡∏Ñ‡∏•‡∏±‡∏á
            .populate("createdBy")
            .populate("updatedBy")
            .populate("items.productId", "name barcode")
            .populate("items.stockId")
            .populate("stockLots", "_id batchNumber status qcStatus")

            .sort({ createdAt: -1 });

        res.status(200).json({ success: true, message: "‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ PO ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: orders });
    } catch (error) {
        console.error("Get PO Error:", error);
        res.status(500).json({ success: false, message: "Server error while fetching POs" });
    }
};

/* ==========================
   üìÑ ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î PO ‡∏ï‡∏≤‡∏° ID
========================== */
export const getPurchaseOrderById = async (req: Request, res: Response): Promise<void> => {
    try {
        const { id } = req.params;

        const po = await PurchaseOrder.findById(id)
            .populate("supplierId", "companyName phoneNumber email") // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• supplier ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
            .populate("location", "name code") // ‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
            .populate("createdBy", "username email role")
            .populate("updatedBy", "username email role")
            .populate("items.productId", "name barcode")
            .populate("items.stockId", "totalQuantity status")
            .populate({
                path: "stockLots", // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ
                populate: [
                    { path: "productId", select: "name barcode" },
                    { path: "stockId", select: "totalQuantity status" },
                    { path: "supplierId", select: "companyName" },
                    { path: "location", select: "name" },
                ],
            });

        if (!po) {
            res.status(404).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö PurchaseOrder" });
            return;
        }

        res.status(200).json({
            success: true,
            message: "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PO ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚úÖ",
            data: po,
        });
    } catch (error) {
        console.error("‚ùå Get PO By ID Error:", error);
        res.status(500).json({
            success: false,
            message: "Server error while fetching PO",
        });
    }
};
/* ==========================
   üìã ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ PO ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
========================== */
export const getAllPurchaseOrders = async (req: Request, res: Response): Promise<void> => {
    try {
        const purchaseOrders = await PurchaseOrder.find()
            .populate("supplierId", "companyName")
            .populate("location", "name code") // ‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
            .populate("stockLots", "_id status qcStatus") // ‚úÖ ‡∏î‡∏∂‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ field ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
            .sort({ createdAt: -1 })
            .lean();

        res.status(200).json({
            success: true,
            message: "‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚úÖ",
            data: purchaseOrders.map((po) => ({
                _id: po._id,
                purchaseOrderNumber: po.purchaseOrderNumber,
                supplierCompany: po.supplierId?.companyName || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏",
                totalLots: po.stockLots?.length || 0, // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡πá‡∏≠‡∏ï‡πÉ‡∏ô PO
                qcStatus: po.qcStatus || "‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö",
                status: po.status,
                createdAt: po.createdAt,
            })),
        });
    } catch (error) {
        console.error("‚ùå Get All PO Error:", error);
        res.status(500).json({
            success: false,
            message: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏î‡πâ",
            error,
        });
    }
};
/* ========================================================
   üßæ CREATE PURCHASE ORDER
   ‚Üí ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á StockLot (‡∏£‡∏≠ confirm ‡∏Å‡πà‡∏≠‡∏ô)
======================================================== */
export const createPurchaseOrder = async (req: Request, res: Response): Promise<void> => {
    try {
        const token = req.header("Authorization")?.split(" ")[1];
        if (!token) {
            res.status(401).json({ success: false, message: "Unauthorized, no token" });
            return;
        }

        const decoded = verifyToken(token);
        if (typeof decoded === "string" || !("userId" in decoded)) {
            res.status(401).json({ success: false, message: "Invalid token" });
            return;
        }

        const { purchaseOrderNumber, supplierId, supplierCompany, location, items, invoiceNumber } = req.body;
        if (!Array.isArray(items) || items.length === 0) {
            res.status(400).json({ success: false, message: "Items are required" });
            return;
        }

        // üîç ‡∏´‡∏≤ Supplier / Warehouse
        const supplierDoc = await ensureObjectIdOrByName(Supplier, supplierId, "companyName");
        if (!supplierDoc) {
            res.status(400).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö Supplier" });
            return;
        }

        const warehouseDoc =
            (await ensureObjectIdOrByName(Warehouse, location, "name")) ||
            (await Warehouse.findOne({ name: location }).lean());
        if (!warehouseDoc) {
            res.status(400).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏•‡∏±‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤" });
            return;
        }

        // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á items ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏° (‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á lot)
        const itemsWithTotal = items.map((it: any) => ({
            ...it,
            total: Number(it.quantity || 0) * Number(it.costPrice || 0),
        }));

        const totalAmount = itemsWithTotal.reduce((sum: number, it: any) => sum + Number(it.total || 0), 0);

        // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á PO ‡∏à‡∏£‡∏¥‡∏á
        const po = await PurchaseOrder.create({
            purchaseOrderNumber,
            supplierId: supplierDoc._id,
            supplierCompany: supplierCompany ?? supplierDoc.companyName,
            location: warehouseDoc._id,
            items: itemsWithTotal,
            totalAmount,
            invoiceNumber: invoiceNumber || generateInvoiceNumber(),
            createdBy: decoded.userId,
            status: "‡∏£‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£",
            stockLots: [], // ‚úÖ ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏•‡πá‡∏≠‡∏ï‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ
        });

        res.status(201).json({
            success: true,
            message: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡πá‡∏≠‡∏ï‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤)",
            data: po,
        });
    } catch (error) {
        console.error("‚ùå Create PO Error:", error);
        res.status(500).json({
            success: false,
            message: "Server error while creating PO",
        });
    }
};

export const confirmPurchaseOrder = async (req: Request, res: Response): Promise<void> => {
    try {
        const { id } = req.params;
        const token = req.header("Authorization")?.split(" ")[1];
        if (!token) {
            res.status(401).json({ success: false, message: "Unauthorized" });
            return;
        }

        const decoded = verifyToken(token);
        if (typeof decoded === "string" || !("userId" in decoded)) {
            res.status(401).json({ success: false, message: "Invalid token" });
            return;
        }

        const po = await PurchaseOrder.findById(id);
        if (!po) {
            res.status(404).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠" });
            return;
        }

        if (po.status !== "‡∏£‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£") {
            res.status(400).json({ success: false, message: "PO ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß" });
            return;
        }

        const supplierDoc = await Supplier.findById(po.supplierId).lean<{
            _id: mongoose.Types.ObjectId;
            companyName: string;
            code?: string;
        } | null>();
        const warehouseDoc = await Warehouse.findById(po.location).lean<{
            _id: mongoose.Types.ObjectId;
            name: string;
            code?: string;
        } | null>();

        if (!supplierDoc || !warehouseDoc) {
            res.status(400).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Supplier ‡∏´‡∏£‡∏∑‡∏≠ Warehouse" });
            return;
        }

        const supplierCode = supplierDoc.code ?? "SP00";
        const warehouseCode = warehouseDoc.code ?? "WH00";

        const stockLotIds: mongoose.Types.ObjectId[] = [];

        // ‚úÖ ‡∏ß‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á StockLot ‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô
        for (const raw of po.items) {
            const batchNumber =
                raw.batchNumber && String(raw.batchNumber).trim() !== ""
                    ? String(raw.batchNumber).trim()
                    : await generateBatchNumber(warehouseCode, supplierCode, raw.productId.toString());

            const productDoc = await Product.findById(raw.productId)
                .select("barcode name")
                .lean<{ _id: mongoose.Types.ObjectId; barcode: string; name: string } | null>();

            if (!productDoc) {
                console.warn(`‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ID: ${raw.productId}`);
                continue;
            }

            let stock = await Stock.findOne({
                productId: raw.productId,
                location: warehouseDoc._id,
            });

            if (!stock) {
                stock = await Stock.create({
                    productId: raw.productId,
                    userId: decoded.userId,
                    supplierId: supplierDoc._id,
                    supplierName: supplierDoc.companyName,
                    location: warehouseDoc._id,
                    barcode: productDoc.barcode,
                    totalQuantity: 0,
                    threshold: raw.threshold ?? 5,
                    status: "‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡∏≤‡∏¢",
                    isActive: true,
                });
            }

            // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á StockLot (‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö QC)
            const stockLot = await StockLot.create({
                stockId: stock._id,
                productId: raw.productId,
                supplierId: supplierDoc._id,
                supplierName: supplierDoc.companyName,
                userId: decoded.userId,
                location: warehouseDoc._id,
                purchaseOrderNumber: po.purchaseOrderNumber,
                barcode: productDoc.barcode,
                batchNumber,
                expiryDate: raw.expiryDate,
                quantity: raw.quantity,
                costPrice: raw.costPrice,
                salePrice: raw.salePrice ?? raw.costPrice,
                status: "‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö QC",
                isActive: false,
                isTemporary: true,
                purchaseOrderId: po._id,
            });

            // ‚úÖ update item ‡πÉ‡∏ô PO ‡πÉ‡∏´‡πâ‡∏°‡∏µ batchNumber ‡∏î‡πâ‡∏ß‡∏¢
            raw.batchNumber = batchNumber;
            stockLotIds.push(stockLot._id);
        }

        // ‚úÖ update PO
        po.status = "‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß";
        po.qcStatus = "‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö";
        po.stockLots = stockLotIds;
        po.receivedAt = new Date();
        po.updatedBy = (decoded as any).userId;
        po.markModified("items"); // ‚úÖ ‡πÅ‡∏à‡πâ‡∏á mongoose ‡∏ß‡πà‡∏≤ items ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß

        await po.save();

        res.status(200).json({
            success: true,
            message: "‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÉ‡∏ö‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡πá‡∏≠‡∏ï‡πÅ‡∏•‡∏∞ batchNumber ‡πÅ‡∏•‡πâ‡∏ß)",
            data: po,
        });
    } catch (error) {
        console.error("‚ùå Confirm PO Error:", error);
        res.status(500).json({ success: false, message: "Server error while confirming PO" });
    }
};


/* ========================================================
   üîÅ RETURN PURCHASE ORDER
   ‚Üí ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏ì‡∏µ QC ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô
======================================================== */
export const returnPurchaseOrder = async (req: Request, res: Response): Promise<void> => {
    try {
        const { id } = req.params;
        const token = req.header("Authorization")?.split(" ")[1];
        if (!token) {
            res.status(401).json({ success: false, message: "Unauthorized" });
            return;
        }

        const decoded = verifyToken(token);
        if (typeof decoded === "string" || !("userId" in decoded)) {
            res.status(401).json({ success: false, message: "Invalid token" });
            return;
        }

        const po = await PurchaseOrder.findById(id);
        if (!po) {
            res.status(404).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö PurchaseOrder" });
            return;
        }

        if (po.status !== "‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô QC - ‡∏£‡∏≠‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤") {
            res.status(400).json({ success: false, message: "PO ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ" });
            return;
        }

        for (const item of po.items as any[]) {
            const lot = await StockLot.findById(item.stockLotId);
            if (!lot) continue;

            lot.status = "‡∏£‡∏≠‡∏Ñ‡∏±‡∏î‡∏≠‡∏≠‡∏Å";
            lot.isActive = false;
            lot.isTemporary = true;
            await lot.save();

            await StockTransaction.create({
                stockId: lot.stockId,
                productId: lot.productId,
                stockLotId: lot._id,
                type: "RETURN",
                quantity: item.quantity,
                costPrice: item.costPrice,
                userId: decoded.userId,
                notes: `‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ | PO ${po.purchaseOrderNumber} | Batch ${lot.batchNumber}`,
            });
        }

        po.status = "‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô QC - ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß";
        po.returnedAt = new Date();
        po.updatedBy = (decoded as any).userId;
        await po.save();

        res.status(200).json({ success: true, message: "‡∏Ñ‡∏∑‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢ ‚úÖ", data: po });
    } catch (error) {
        console.error("‚ùå Return PO Error:", error);
        res.status(500).json({ success: false, message: "Server error while returning PO" });
    }
};

/* ========================================================
   ‚ùå CANCEL PURCHASE ORDER
======================================================== */
export const cancelPurchaseOrder = async (req: Request, res: Response): Promise<void> => {
    try {
        const token = req.header("Authorization")?.split(" ")[1];
        if (!token) {
            res.status(401).json({ success: false, message: "Unauthorized, no token" });
            return;
        }

        const decoded = verifyToken(token);
        if (typeof decoded === "string" || !("userId" in decoded)) {
            res.status(401).json({ success: false, message: "Invalid token" });
            return;
        }

        const { id } = req.params;
        const po = await PurchaseOrder.findById(id);
        if (!po) {
            res.status(404).json({ success: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö PurchaseOrder" });
            return;
        }

        if (po.status !== "‡∏£‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£") {
            res.status(400).json({
                success: false,
                message: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å PO ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô QC ‡πÑ‡∏î‡πâ",
            });
            return;
        }

        po.status = "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å";
        po.updatedBy = (decoded as any).userId;
        await po.save();

        // ‡∏•‡∏ö StockLot ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å PO ‡∏ô‡∏µ‡πâ
        await StockLot.deleteMany({ _id: { $in: po.items.map((x: any) => x.stockLotId) } });

        res.status(200).json({ success: true, message: "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å PO ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚úÖ", data: po });
    } catch (error) {
        console.error("‚ùå Cancel PO Error:", error);
        res.status(500).json({ success: false, message: "Server error while cancelling PO" });
    }
};
